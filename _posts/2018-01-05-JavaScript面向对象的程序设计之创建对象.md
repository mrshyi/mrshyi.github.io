---
title: JavaScript面向对象的程序设计之创建对象
date: 2018-01-05 13:42:46
categories: FE
tags: JavaScript
---
1. Object构造函数或对象字面量
缺点：使用一个接口创建很多对象，会产生大量重复代码

2. 工厂模式
抽象了创建具体对象的过程，用函数来封装以特定接口创建对象的细节
优点：解决了创建相似对象的问题（1）
缺点：对象识别问题

3. 构造函数模式
使用构造函数创建特定类型的对象;
优点：创建自定义的构造函数可以将它的实例标识为一种特定的类型
缺点：每个方法都要在实例上重新创建一遍（不同实例上的同名函数是不相等的，可以通过转移到构造函数外部解决，但是新问题在全局作用域定义的函数只能被某个对象想用，如果数量多，则没有封装型）
使用new操作符创建对象的新实例：
a.创建一个新对象；
b.将构造函数的作用域赋给新对象
c.执行构造函数中的代码（为这个新对象添加属性）
d.返回新对象

4. 原型模式
每个函数都有一个`prototype(原型)`属性，是一个指向一个对象的指针。这个对象包含可以由特定类型的所有实例共享的属性和方法。即`prototype`就是通过调用构造函数而创建的那个对象实例的原型对象。
优点：让所有对象实例共享它所包含的属性和方法。
缺点：没有参数初始化，所有实例默认情况都将取得相同的属性值。最大问题是由于其共享的本性导致包含引用类型值的属性也被共享

5. 组合使用构造函数模式和原型模式
创建自定义类型最常见的方式。构造函数模式用于定义实例属性，原型模式用于定义方法和共享的属性.
用来定义引用模式的一种默认模式。
优点：每个实例都有自己的实例属性的副本，同时又共享着对方法的引用，最大限度节省了内存，同时还支持向构造函数传递参数
缺点：同时存在独立的构造函数和原型

6. 动态原型模式
把所有信息封装在构造函数中，通过在构造函数中初始化原型（仅在必要的情况下）
通过检查某个应该存在的方法是否有效，来决定是否需要初始化原型
优点：保持了同时使用构造函数和原型的优点，又解决了5中的问题
注意：使用动态原型模式时，不能使用对象字面量重写原型，否则会切断现有实例与新原型之间的联系

7. 寄生构造函数模式 = 构造函数+工厂模式
创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回新创建的对象
应用场景：在特殊情况下用来为对象创建构造函数
注意：返回的对象与构造函数或者与构造函数的原型属性之间没有关系。不能依赖instanceof操作符来确定对象的类型，尽量不要使用这种模式

8. 稳妥构造函数模式
没有公共属性，方法也不引用`this`
a.新创建对象的实例方法不引用`this`
b.不实用`new`操作符调用构造函数